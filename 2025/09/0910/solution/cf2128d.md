Sum of LDS 算法思路（纯文本版）
题目回顾

我们需要计算 所有子数组的最长下降子序列 (LDS) 的长度之和。
输入是一个排列，并且满足条件：

max(p[i], p[i+1]) > p[i+2]，对所有 1 ≤ i ≤ n-2。

核心性质

结论：
在这个限制条件下，一个子数组的 LDS 长度 = 1 + 子数组中的下降对数量。

下降对：若 p[i] > p[i+1]，则 (p[i], p[i+1]) 是一个下降对。

为什么成立？

任意子数组的 LDS ≥ 1。

每出现一个下降对，就能使 LDS 增加 1。

例子：[6,1] 有 1 个下降对 → LDS=2

例子：[6,5,2] 有 2 个下降对 → LDS=3

由于排列满足限制条件，不可能出现更长的下降模式。

因此：
LDS([l,r]) = 1 + （l ≤ i < r 且 p[i] > p[i+1] 的 i 的数量）

总和拆分

我们要求：
ans = 所有子数组的 LDS([l,r]) 之和

代入公式：
ans = （所有子数组的常数项） + （下降对的贡献）

部分一：常数项

每个子数组至少贡献 1。
子数组总数为： n*(n+1)/2

部分二：下降对的贡献

考虑某个下降对 (i,i+1)，它被多少子数组包含？

条件：子数组 [l,r] 要满足 l ≤ i 且 r ≥ i+1

左端点选择数：i

右端点选择数：(n - i)

总共：i * (n - i) 个子数组

因此总和为：
ans = n*(n+1)/2 + Σ (i * (n - i))，其中求和范围是所有满足 p[i] > p[i+1] 的 i

算法流程

读入数组 p。

初始化答案 ans = n*(n+1)/2。

枚举 i = 1..n-1：

如果 p[i] > p[i+1]，则 ans += i * (n - i)。

输出 ans。

时间复杂度

每个测试用例 O(n)。

总 n ≤ 5 * 10^5，可行。

总结

关键观察：
LDS = 1 + 子数组下降对数量

这样就把复杂的 “最长下降子序列” 问题转化为 “统计下降对的贡献”。