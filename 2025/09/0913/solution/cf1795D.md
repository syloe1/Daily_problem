解法步骤

预处理每个三元组

计算最佳贡献值。

记录能取最大值的“落单点选择”集合及其数量。

计算全局最大值 W

所有三元组的最大贡献值之和。

计数方案数

对每个三元组：它的最优选择集合确定了“落单点可能是谁”，对应的红/蓝情况有 2 种（落单点染红或染蓝）。

本质上：每个三元组最优时贡献相同，不管落单点选红还是蓝。

所以每个三元组给出 c 种方式（c = 能达到最大值的落单点数 × 2，因为单点可以是红也可以是蓝）。

全局必须保证红蓝各 
𝑛
/
2
n/2，即 
𝑚
/
2
m/2 组三元组走 (2,1)，
𝑚
/
2
m/2 组三元组走 (1,2)。

这就变成：

每个三元组可以选择 (2,1) 或 (1,2)，都有相同贡献。

我们只需要数：有多少方法从 m 个三元组中，选出恰好 m/2 个走 (2,1)，剩下 m/2 个走 (1,2)。

并且，每个三元组内实现最大值的方式数不同，要乘上。

核心计数公式

设第 
𝑖
i 个三元组实现最大贡献的方式数为 
𝑐
𝑖
c
i
	​

（这里注意不乘 2，因为落单点可以红或蓝已经包含在 (2,1)/(1,2) 两个方向中）。

更精确：

如果最大值由 k 个落单点实现，则：

(2,1) 染色时有 k 种方式。

(1,2) 染色时也有 k 种方式。

所以每个三元组有 
𝑘
k 种方式贡献给 (2,1)，和 
𝑘
k 种方式贡献给 (1,2)。

全局：

从 m 个三元组选 m/2 个走 (2,1)，其它走 (1,2)。

方案数 = 系数提取自多项式展开：

(
∑
𝑖
=
1
𝑚
𝑘
𝑖
)
?
(
i=1
∑
m
	​

k
i
	​

)?

实际上应这样：
每个三元组贡献一个多项式：
(
𝑘
𝑖
𝑥
+
𝑘
𝑖
𝑦
)
(k
i
	​

x+k
i
	​

y)，其中 x 代表该组三元组选 (2,1)，y 代表选 (1,2)。
总乘积 = 
∏
(
𝑘
𝑖
𝑥
+
𝑘
𝑖
𝑦
)
∏(k
i
	​

x+k
i
	​

y)。
我们要的就是系数 
[
𝑥
𝑚
/
2
𝑦
𝑚
/
2
]
[x
m/2
y
m/2
]。

注意：
𝑘
𝑖
𝑥
+
𝑘
𝑖
𝑦
=
𝑘
𝑖
(
𝑥
+
𝑦
)
k
i
	​

x+k
i
	​

y=k
i
	​

(x+y)。
所以总乘积 = 
(
∏
𝑘
𝑖
)
⋅
(
𝑥
+
𝑦
)
𝑚
(∏k
i
	​

)⋅(x+y)
m
。

因此答案 = 
(
∏
𝑘
𝑖
)
⋅
(
𝑚
𝑚
/
2
)
(∏k
i
	​

)⋅(
m/2
m
	​

)。

总结

最大权值 W = 
∑
𝑖
=
1
𝑚
max contribution of triple i
∑
i=1
m
	​

max contribution of triple i。

最大权值染色数 = 
(
∏
𝑖
=
1
𝑚
𝑘
𝑖
)
×
(
𝑚
𝑚
/
2
)
(
m
o
d
998244353
)
(∏
i=1
m
	​

k
i
	​

)×(
m/2
m
	​

)(mod998244353)。

例子验证
示例 2
n=6
edges: 4 2 6 6 6 4


只有 1 个三元组：边 (4,2,6)。
单点贡献：

a 单点 = 4+2=6

b 单点 = 4+6=10

c 单点 = 2+6=8
→ 最大=10，唯一在 b。 → k=1。

m=2（三元组个数 = n/3 = 2）。
Wait: n=6, m=2，没错。

三元组有 2 个（顶点1,2,3；顶点4,5,6）。
算第一个：4,2,6 → k=1。
第二个：6,6,4 → (6+6=12, 6+4=10, 6+4=10) → 最大=12 → k=1。

所以 
∏
𝑘
𝑖
=
1
∏k
i
	​

=1。

(
2
1
)
=
2
(
1
2
	​

)=2。
答案=2。 ✅

最终 C++ 实现思路

读入 n，m=n/3。

遍历每个三元组，算三条边：

sum1=w1+w2, sum2=w1+w3, sum3=w2+w3。

maxv = max(sum1,sum2,sum3)。

k = count of sums==maxv。

W += maxv。

ways = (ways*k) % MOD。

最后 ways = ways * C(m, m/2) % MOD。
输出 ways。

组合数用预处理阶乘和逆元。